<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <title>Local Outlier Factor &mdash; ml-nest</title>
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css">
    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.8.1/css/all.css">
    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.8.1/css/v4-shims.css">
    <link rel="stylesheet" href="../../../css/theme.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.8.1/css/all.css">
    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.8.1/css/v4-shims.css">
    <link rel="stylesheet" href="../../../css/pheasant.css">
    <script src="//code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script> 
</head>

<body ontouchstart="">
    <div id="container">
        <aside>
            <div class="home">
                <div class="title">
                    <button class="hamburger"></button>
                    <a href="../../.." class="site-name"> ml-nest</a>
                </div>
                <div class="search">
                    <div role="search">
    <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
        <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
    </form>
</div>
                </div>
            </div>
            <nav class="nav">
                <ul class="root">
                    <li class="toctree-l1">
<a class="nav-item" href="../../..">Home</a></li>
                    <li class="toctree-l1"><button class="section nav-item">Algorithms</button>
<ul class="subnav">
    <li class="toctree-l2"><button class="section nav-item hide">Feature Engineering</button>
<ul class="subnav hide">
    <li class="toctree-l3"><button class="section nav-item hide">Feature</button>
<ul class="subnav hide">
    <li class="toctree-l4">
<a class="nav-item" href="../../../about/">Local Outlier Factor</a></li>
</ul></li>
</ul></li>
    <li class="toctree-l2"><button class="section nav-item hide">Feature Elimination</button>
<ul class="subnav hide">
    <li class="toctree-l3">
<a class="nav-item" href="../../../about/">Local Outlier Factor</a></li>
</ul></li>
    <li class="toctree-l2"><button class="section nav-item hide">Classification</button>
<ul class="subnav hide">
    <li class="toctree-l3">
<a class="nav-item" href="../../../about/">License</a></li>
</ul></li>
    <li class="toctree-l2 current"><button class="section nav-item">Clustering</button>
<ul class="subnav">
    <li class="toctree-l3">
<a class="nav-item" href="../../../about/">K-Means</a></li>
    <li class="toctree-l3 current"><a class="nav-item current" href="./">Local Outlier Factor</a>
<ul class="subnav">
<li class="toctree-l4"><a class="nav-item toc" href="#selection-criteria">Selection criteria</a></li>
<li class="toctree-l4"><a class="nav-item toc" href="#how-it-works">How it works?</a></li>
<li class="toctree-l4"><a class="nav-item toc" href="#hyperparameter-selection">Hyperparameter Selection</a></li>
<li class="toctree-l4"><a class="nav-item toc" href="#alternatives">Alternatives</a></li>
<li class="toctree-l4"><a class="nav-item toc" href="#disadvantages">Disadvantages</a></li>
<li class="toctree-l4"><a class="nav-item toc" href="#alternatives_1">Alternatives</a></li>
</ul></li>
</ul></li>
</ul></li>
                    <li class="toctree-l1"><button class="section nav-item">Technology</button>
<ul class="subnav">
    <li class="toctree-l2"><button class="section nav-item hide">SQL</button>
<ul class="subnav hide">
    <li class="toctree-l3"><a class="nav-item" href="../../../Technology/SQL/Indexing/">Indexing</a></li>
</ul></li>
</ul></li>
                    <li class="toctree-l1"><button class="section nav-item">Documentation</button>
<ul class="subnav">
    <li class="toctree-l2"><a class="nav-item" href="../../../Documentations/mk-docs/">mk-docs</a></li>
    <li class="toctree-l2">
<a class="nav-item" href="../../../Documentations/blob-storage/">azure blob storage</a></li>
</ul></li>
                    <li class="toctree-l1"><button class="section nav-item">Misc</button>
<ul class="subnav">
    <li class="toctree-l2"><a class="nav-item" href="../../../Misc/email_notifications/">Email Notifications</a></li>
</ul></li>
                </ul>
            </nav>
            <div class="repo">
    <div class="previous"><a href="../../../about/">&laquo; Previous</a></div>
    <div class="next"><a href="../../../Technology/SQL/Indexing/">Next &raquo;</a></div>
</div>
        </aside>
        <div id="spacer"><button class="arrow"></button></div>
        <main>
            <div class="home-top">
                <button class="hamburger"></button>
                <a href="../../.." class="site-name"> ml-nest</a>
            </div>
            <div id="main">
                <nav class="breadcrumbs">
<ul>
    <li>Algorithms &raquo; </li><li>Clustering</li>
</ul>
</nav>
                <div id="content">
<h1 id="introduction">Introduction</h1>
<ul>
<li>compares local density of the outliers to the local density of its K neighbours</li>
<li>if a points local density is significantly lower than its K nearest neighbours, it can be called as an anomaly</li>
<li>this density is calculated by the inverse of the reachability distance</li>
</ul>
<h2 id="selection-criteria">Selection criteria</h2>
<ul>
<li>used when the anomaly is very close to the actual points but less densely packed</li>
<li>will flag high density and sparse clusters as normal, but a loose point near a dense cluster as an anomaly</li>
</ul>
<h2 id="how-it-works">How it works?</h2>
<ul>
<li>Considering a dataset which has already formed clusters</li>
</ul>
<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python">import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

# Generate normal (not abnormal) training observations
X = 0.3 * np.random.randn(100, 2) # create a normal distribution between 0 and 1 of the required shape
X_train = np.r_[X + 2, X - 2] # concat multiple array&#39;s of the same shape together

# Generate new normal (not abnormal) observations
X = 0.3 * np.random.randn(20, 2)
X_test = np.r_[X + 2, X - 2]
# Generate some abnormal novel observations
X_outliers = np.random.uniform(low=-4, high=4, size=(20, 2))

df = pd.DataFrame(np.r_[X_train, X_test, X_outliers], columns = [&#39;x&#39;, &#39;y&#39;])
df.head()</code></pre></div>
<div class="report"><p><span class="count">[1]</span>
<span class="start">2021-04-26 11:31:08</span> (<span class="time">104ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">3.32s</span>)</span></p></div></div>

<div class="cell jupyter display"><div class="content"><table class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>x</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.448091</td>
      <td>2.500459</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.589671</td>
      <td>1.691205</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2.283369</td>
      <td>2.543845</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2.314729</td>
      <td>2.030218</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2.248377</td>
      <td>1.986990</td>
    </tr>
  </tbody>
</table></div></div></div></div>

<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python">plt.scatter(df[&#39;x&#39;], df[&#39;y&#39;])
plt.show()</code></pre></div>
<div class="report"><p><span class="count">[2]</span>
<span class="start">2021-04-26 11:31:08</span> (<span class="time">190ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">3.51s</span>)</span></p></div></div>

<div class="cell jupyter display"><div class="content"><p><img alt="image/png" src="data:image/png;base64,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
"/></p></div></div></div></div>

<ul>
<li><strong>Step 1:</strong> Find K nearest datapoints using eucleidian distance from the point under consideration, we are assuming K to be 3 in this case</li>
</ul>
<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python"># Getting indices for each of the point
temp = df[[&#39;x&#39;, &#39;y&#39;]].reset_index()

# Applying cross join to calculate Euclidean distance
# Adding 0 column for cross join
temp[0] = 0
temp = pd.merge(temp, temp, how = &#39;outer&#39;, on = 0)
# Dropping 0 column
del temp[0]

# Calculating Euclidean distance
temp[&#39;eu_dist&#39;] = ((temp[&#39;x_x&#39;] - temp[&#39;x_y&#39;])**2 + (temp[&#39;y_x&#39;] - temp[&#39;y_y&#39;])**2)**0.5

# Dropping zero values because they will be same point
temp = temp[temp[&#39;eu_dist&#39;] != 0]

# Adding a rank by distance to each datapoint to get the closest K datapoint
temp[&#34;rank&#34;] = temp.groupby(&#34;index_x&#34;)[&#34;eu_dist&#34;].rank(&#34;min&#34;, ascending=True)

#let k = 2
k = 3
temp = temp[temp[&#39;rank&#39;] &lt;=k]

temp.head()</code></pre></div>
<div class="report"><p><span class="count">[3]</span>
<span class="start">2021-04-26 11:40:47</span> (<span class="time">139ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">785ms</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;df&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-10-8f43e2957478&gt; in &lt;module&gt;
      1 # Getting indices for each of the point
----&gt; 2 temp = df[[&#39;x&#39;, &#39;y&#39;]].reset_index()
      3 
      4 # Applying cross join to calculate Euclidean distance
      5 # Adding 0 column for cross join</code></pre></div></div></div></div>

<ul>
<li><strong>Step 2:</strong> Calculate reachability distance from the considered point to its neighbours (which also equals the maximum distance between Kth distance of the other point or the euclidian distance of that point)</li>
</ul>
<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python"># Sorting values to get the kth distance for each point
temp_2 = temp.sort_values([&#39;index_x&#39;, &#39;eu_dist&#39;], ascending = [True,False]).reset_index(drop = True)[[&#39;index_x&#39;, &#39;index_y&#39;,&#39;eu_dist&#39;]]

# Getting the kth value
min_indices = []

for i in np.unique(np.array(temp_2[&#39;index_x&#39;])):
    min_indices.append(min(temp_2[temp_2[&#39;index_x&#39;] == i].index))

kth_distance = temp_2[temp_2.index.isin(min_indices)]

kth_distance = kth_distance.rename(columns={&#34;eu_dist&#34;: &#34;kth_dist&#34;, &#34;index_x&#34;: &#34;point_label&#34;})
del kth_distance[&#39;index_y&#39;]

kth_distance.head()</code></pre></div>
<div class="report"><p><span class="count">[4]</span>
<span class="start">2021-04-26 11:40:47</span> (<span class="time">255ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">1.04s</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;temp&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-11-a3e6eabb29b3&gt; in &lt;module&gt;
      1 # Sorting values to get the kth distance for each point
----&gt; 2 temp_2 = temp.sort_values([&#39;index_x&#39;, &#39;eu_dist&#39;], ascending = [True,False]).reset_index(drop = True)[[&#39;index_x&#39;, &#39;index_y&#39;,&#39;eu_dist&#39;]]
      3 
      4 # Getting the kth value
      5 min_indices = []</code></pre></div></div></div></div>

<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python"># Calculating reachability distance
reach_dist = pd.merge(temp_2, kth_distance, left_on = &#39;index_y&#39;, right_on= &#39;point_label&#39;, how = &#39;left&#39;)
del reach_dist[&#39;point_label&#39;]

reach_dist[&#39;rd&#39;] = reach_dist[[&#39;eu_dist&#39;,&#39;kth_dist&#39;]].max(axis = 1)
del reach_dist[&#39;eu_dist&#39;]
del reach_dist[&#39;kth_dist&#39;]

reach_dist.head()</code></pre></div>
<div class="report"><p><span class="count">[5]</span>
<span class="start">2021-04-26 11:40:47</span> (<span class="time">157ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">1.20s</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;pd&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-12-71b6a020d6dd&gt; in &lt;module&gt;
      1 # Calculating reachability distance
----&gt; 2 reach_dist = pd.merge(temp_2, kth_distance, left_on = &#39;index_y&#39;, right_on= &#39;point_label&#39;, how = &#39;left&#39;)
      3 del reach_dist[&#39;point_label&#39;]
      4 
      5 reach_dist[&#39;rd&#39;] = reach_dist[[&#39;eu_dist&#39;,&#39;kth_dist&#39;]].max(axis = 1)</code></pre></div></div></div></div>

<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python">mean_rd = pd.DataFrame(reach_dist.groupby([&#39;index_x&#39;])[&#39;rd&#39;].mean()).reset_index()

mean_rd = mean_rd.rename(columns={&#34;index_x&#34;: &#34;point_label&#34;})
mean_rd.head()</code></pre></div>
<div class="report"><p><span class="count">[6]</span>
<span class="start">2021-04-26 11:40:47</span> (<span class="time">105ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">1.30s</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;pd&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-13-637b1bcafcd4&gt; in &lt;module&gt;
----&gt; 1 mean_rd = pd.DataFrame(reach_dist.groupby([&#39;index_x&#39;])[&#39;rd&#39;].mean()).reset_index()
      2 
      3 mean_rd = mean_rd.rename(columns={&#34;index_x&#34;: &#34;point_label&#34;})
      4 mean_rd.head()</code></pre></div></div></div></div>

<ul>
<li><strong>Step 3:</strong> Calculate local reachability density</li>
</ul>
<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python"># Getting LRD(local reachability density) for individual points
lrd_all_pts = mean_rd.copy()
lrd_all_pts[&#39;lrd&#39;] = 1/lrd_all_pts[&#39;rd&#39;]
del lrd_all_pts[&#39;rd&#39;]

lrd_all_pts.head()</code></pre></div>
<div class="report"><p><span class="count">[7]</span>
<span class="start">2021-04-26 11:40:47</span> (<span class="time">105ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">1.41s</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;mean_rd&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-14-9fc93de50496&gt; in &lt;module&gt;
      1 # Getting LRD(local reachability density) for individual points
----&gt; 2 lrd_all_pts = mean_rd.copy()
      3 lrd_all_pts[&#39;lrd&#39;] = 1/lrd_all_pts[&#39;rd&#39;]
      4 del lrd_all_pts[&#39;rd&#39;]
      5</code></pre></div></div></div></div>

<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python"># Getting average LRD from all the neighbours
avg_lrd = pd.merge(temp_2[[&#39;index_x&#39;, &#39;index_y&#39;]], lrd_all_pts, left_on = &#39;index_y&#39;, right_on = &#39;point_label&#39;, how = &#39;left&#39;)
avg_lrd = pd.DataFrame(avg_lrd.groupby([&#39;index_x&#39;])[&#39;lrd&#39;].mean()).reset_index()
avg_lrd = avg_lrd.rename({&#34;index_x&#34;:&#34;point_label&#34;, &#34;lrd&#34;:&#34;avg_lrd_neigh&#34;}, axis = 1)

avg_lrd.head()</code></pre></div>
<div class="report"><p><span class="count">[8]</span>
<span class="start">2021-04-26 11:40:48</span> (<span class="time">106ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">1.51s</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;pd&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-15-d0f1691c03bf&gt; in &lt;module&gt;
      1 # Getting average LRD from all the neighbours
----&gt; 2 avg_lrd = pd.merge(temp_2[[&#39;index_x&#39;, &#39;index_y&#39;]], lrd_all_pts, left_on = &#39;index_y&#39;, right_on = &#39;point_label&#39;, how = &#39;left&#39;)
      3 avg_lrd = pd.DataFrame(avg_lrd.groupby([&#39;index_x&#39;])[&#39;lrd&#39;].mean()).reset_index()
      4 avg_lrd = avg_lrd.rename({&#34;index_x&#34;:&#34;point_label&#34;, &#34;lrd&#34;:&#34;avg_lrd_neigh&#34;}, axis = 1)
      5</code></pre></div></div></div></div>

<ul>
<li><strong>Step 4:</strong> Calculate lof</li>
</ul>
<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python"># Calculating LOF by dividing average LRD of neighbours to the actual LRD of the point
lof = pd.merge(avg_lrd, lrd_all_pts, on = &#39;point_label&#39;, how = &#39;left&#39;)
lof[&#39;lof&#39;] = lof[&#39;avg_lrd_neigh&#39;]/ lof[&#39;lrd&#39;]
del lof[&#39;lrd&#39;]
del lof[&#39;avg_lrd_neigh&#39;]

lof.sort_values(&#39;lof&#39;, ascending = False)[:10]</code></pre></div>
<div class="report"><p><span class="count">[9]</span>
<span class="start">2021-04-26 11:40:48</span> (<span class="time">128ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">1.64s</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;pd&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-16-dda84c93357d&gt; in &lt;module&gt;
      1 # Calculating LOF by dividing average LRD of neighbours to the actual LRD of the point
----&gt; 2 lof = pd.merge(avg_lrd, lrd_all_pts, on = &#39;point_label&#39;, how = &#39;left&#39;)
      3 lof[&#39;lof&#39;] = lof[&#39;avg_lrd_neigh&#39;]/ lof[&#39;lrd&#39;]
      4 del lof[&#39;lrd&#39;]
      5 del lof[&#39;avg_lrd_neigh&#39;]</code></pre></div></div></div></div>

<ul>
<li>More the value of this LOF is higher, more the probablity of this point becoming an anomaly</li>
</ul>
<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python"># Getting x and y coordinates for the given points
lof_df = pd.merge(df[[&#39;x&#39;, &#39;y&#39;]].reset_index(), lof, left_on = &#39;index&#39;, right_on = &#39;point_label&#39;, how = &#39;left&#39;)
del lof_df[&#39;index&#39;]
del lof_df[&#39;point_label&#39;]

lof_df.head()</code></pre></div>
<div class="report"><p><span class="count">[10]</span>
<span class="start">2021-04-26 11:40:48</span> (<span class="time">181ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">1.82s</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;pd&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-17-4d1dc290ecc1&gt; in &lt;module&gt;
      1 # Getting x and y coordinates for the given points
----&gt; 2 lof_df = pd.merge(df[[&#39;x&#39;, &#39;y&#39;]].reset_index(), lof, left_on = &#39;index&#39;, right_on = &#39;point_label&#39;, how = &#39;left&#39;)
      3 del lof_df[&#39;index&#39;]
      4 del lof_df[&#39;point_label&#39;]
      5</code></pre></div></div></div></div>

<div class="pheasant-fenced-code"><div class="cached"><div class="cell jupyter input"><div class="code"><pre><code class="python">thresh = 2
plt.scatter(lof_df[lof_df[&#39;lof&#39;] &gt; thresh][&#39;x&#39;], lof_df[lof_df[&#39;lof&#39;] &gt; thresh][&#39;y&#39;])
plt.scatter(lof_df[lof_df[&#39;lof&#39;] &lt;= thresh][&#39;x&#39;], lof_df[lof_df[&#39;lof&#39;] &lt;= thresh][&#39;y&#39;])

plt.show()</code></pre></div>
<div class="report"><p><span class="count">[11]</span>
<span class="start">2021-04-26 11:40:48</span> (<span class="time">106ms</span>)
<span class="right"><span class="kernel">python3</span> (<span class="total">1.93s</span>)</span></p></div></div><div class="cell jupyter error"><div class="code"><pre><code class="nohighlight">NameError: name &#39;plt&#39; is not defined</code></pre></div>
      <div class="report"><pre><code class="nohighlight">NameError                                 Traceback (most recent call last)
&lt;ipython-input-18-4969c258b790&gt; in &lt;module&gt;
      1 thresh = 2
----&gt; 2 plt.scatter(lof_df[lof_df[&#39;lof&#39;] &gt; thresh][&#39;x&#39;], lof_df[lof_df[&#39;lof&#39;] &gt; thresh][&#39;y&#39;])
      3 plt.scatter(lof_df[lof_df[&#39;lof&#39;] &lt;= thresh][&#39;x&#39;], lof_df[lof_df[&#39;lof&#39;] &lt;= thresh][&#39;y&#39;])
      4 
      5 plt.show()</code></pre></div></div></div></div>

<h2 id="hyperparameter-selection">Hyperparameter Selection</h2>
<ul>
<li>How to select the correct K-value?<ul>
<li>Minimum K should be considered as the number of points which can be considered as a cluster, so that other clusters with less points can be considered outliers. When K &lt; 10, LOF is highly volatile</li>
<li>Max K should be selected as the points to be considered as outliers if clustered together</li>
</ul>
</li>
</ul>
<h2 id="alternatives">Alternatives</h2>
<p>How to select the correct value for LOF</p>
<p>User dependendent</p>
<h2 id="disadvantages">Disadvantages</h2>
<ul>
<li>LOF &lt; 1 is definitely an inlier but the inverse statement may not be as true</li>
<li>strong local fluctuations may increase the number of false positives</li>
</ul>
<h2 id="alternatives_1">Alternatives</h2>
<ul>
<li>can use feature bagging instead to reduce FP</li>
<li>can use local outlier probability to reduce the chance of choosing the wrong K</li>
</ul>
<p>Why reachability distance is considered instead of euclidean distance?</p></div>
                <footer>
    <div class="footer-buttons">
        <div class="previous"><a href="../../../about/" title="K-Means"><span>Previous</span></a></div>
        <div class="next"><a href="../../../Technology/SQL/Indexing/" title="Indexing"><span>Next</span></a></div>
    </div>
    <div class="footer-note">
        <p>
            Built with <a href="http://www.mkdocs.org">MkDocs</a> using
            <a href="https://github.com/daizutabi/mkdocs-ivory">Ivory theme</a>.
        </p>
    </div>
</footer>
            </div>
        </main>
    </div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js"></script>
    <script src="../../../js/pheasant.js"></script>
    <script src="../../../search/main.js"></script>
</body>

</html>